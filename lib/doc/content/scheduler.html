<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" type="text/css" href="../code_style.css">
    <script src="../highlight.pack.js"></script>
    <script src="../code.js"></script>

    <link rel="stylesheet" type="text/css" href="../style.css">
    <meta charset="UTF-8">
    <title>Scheduler / apptronic.net core framework</title>
</head>
<body>
<div class="content">
    <div class="inner_link"><a href="../index.html">Documentation</a> - Scheduler</div>
    <div class="page_title">Scheduler</div>
    <div class="section_paragraph">
        <div class="code_inline">Scheduler</div>
        responsible for threading inside framework. Instead of using threads directly all actions are executed using
        <div class="code_inline">Worker</div><!--remove_space-->s, and
        <div class="code_inline">Scheduler</div>
        is responsible for providing workers.
    </div>

    <div class="section_subtitle">Workers</div>
    <div class="section_paragraph">
        <div class="code_inline">Worker</div>
        is executor of actions. Each
        <div class="code_inline">Worker</div>
        uses it's own internal logic of running actions. Common types of workers is:
        <ul>
            <li><b>Synchronous</b>
                <div class="code_inline">Worker</div>
                executes all actions immediately in current thread.
            </li>
            <li><b>Background thread pool</b>
                <div class="code_inline">Worker</div>
                executes all actions in background threads used from pool. Maximum size of pool defined at the moment of
                <div class="code_inline">Worker</div>
                creation.
            </li>
            <li><b>Specific thread</b>
                <div class="code_inline">Worker</div>
                runs actions only in desired thread. For example, Android UI
                <div class="code_inline">Worker</div>
                always executes actions and main Android thread. Also there is
                <div class="code_inline">Worker</div>
                which executes actions in main thread, but asynchronously.
            </li>
            <li><b>Serial</b>
                <div class="code_inline">Worker</div>
                executes tasks one after another, but have limited size of queue, if new action is received for
                execution while old action is still executing and queue is filled - then
                <div class="code_inline">Worker</div>
                removes first action from queue before adding next action. It means that action, executed in this
                worker, have no guarantee to be executed, so this worker should be used very carefully in places where
                broking execution chain is not supported. Main usage of this
                <div class="code_inline">Worker</div>
                is for places where having all intermediate results is not required, like info on user interface. If
                source data is changing very often and calculation of displayable state requires many time it can be
                useful to use this
                <div class="code_inline">Worker</div>
                for transformation as it prevents from situation when handling requests take more time then frequency if
                initial data change.
            </li>
        </ul>
        Other types of
        <div class="code_inline">Worker</div><!--remove_space-->s may be implemented and registered in
        <div class="code_inline">Scheduler</div><!--remove_space-->. For example, for testing purposes used synchronous
        <div class="code_inline">Worker</div>
        with deferred executions, when all action executed synchronously, but only when
        <div class="code_inline">Worker</div>
        receives external signal to execute that actions.
    </div>
    <div class="section_paragraph">
        To create new
        <div class="code_inline">Worker</div>
        type it needed to implement
        <div class="code_inline">net.apptronic.core.threading.Worker</div>
        interface:
        <pre><code>class MyWorker : Worker {

    override fun execute(action: Action) {
        // implement execution of action
    }

}</code></pre>
    </div>

    <div class="section_subtitle">WorkerProvider</div>
    <div class="section_paragraph">
        <div class="code_inline">WorkerProvider</div>
        is responsible for providing
        <div class="code_inline">Worker</div>
        from
        <div class="code_inline">Scheduler</div><!--remove_space-->.
        <div class="code_inline">Scheduler</div>
        not operates
        <div class="code_inline">Worker</div><!--remove_space-->s by self by operates
        <div class="code_inline">WorkerProvider</div><!--remove_space-->s and each
        <div class="code_inline">WorkerProvider</div>
        is responsible of how provide
        <div class="code_inline">Worker</div><!--remove_space-->s.
    </div>
    <div class="section_paragraph">
        Two main types of
        <div class="code_inline">WorkerProvider</div>
        is:
        <ul>
            <li><b>InstanceWorkerProvider</b>
                <div class="code_inline">WorkerProvider</div><!--remove_space-->: provides same instance of
                <div class="code_inline">Worker</div>
                for each request.
            </li>
            <li><b>FactoryWorkerProvider</b>
                <div class="code_inline">WorkerProvider</div><!--remove_space-->: provides new instance
                <div class="code_inline">Worker</div>
                for each request.
            </li>
        </ul>
    </div>

    <div class="section_title">WorkerDefinition</div>
    <div class="section_paragraph">
        <div class="code_inline">WorkerDefinition</div>
        is used as key for assigning and requesting
        <div class="code_inline">Worker</div><!--remove_space-->s from
        <div class="code_inline">Scheduler</div><!--remove_space-->.
        New
        <div class="code_inline">WorkerDefinition</div><!--remove_space-->s can be created by calling:
        <pre><code>val MY_WORKER = defineWorker("MY_WORKER")</code></pre>
        After that worker can be registered in
        <div class="code_inline">Scheduler</div><!--remove_space-->:
        <pre><code>getScheduler().assignWorker(
    MY_WORKER,
    InstanceWorkerProvider(singleThreadWorker())
)</code></pre>
        If
        <div class="code_inline">WorkerDefinition</div>
        is not found in current
        <div class="code_inline">Context</div>
        <div class="code_inline">Scheduler</div>
        then it will be searched in parental
        <div class="code_inline">Context</div><!--remove_space-->s. And if
        <div class="code_inline">WorkerDefinition</div>
        is not found in all then fallback
        <div class="code_inline">Worker</div>
        will be used, which is
        <div class="code_inline">SynchronousWorker</div>
        by default.
    </div>
    <div class="section_paragraph">
        Important thing that
        <div class="code_inline">WorkerDefinition</div>
        instances should be static. Each request of
        <div class="code_inline">WorkerDefinition</div>
        uses reference comparison, so in case if
        <div class="code_inline">WorkerDefinition</div>
        defined not statically it will never find corresponding
        <div class="code_inline">WorkerDefinition</div>
        inside
        <div class="code_inline">Scheduler</div>
        as it will always use different instance of
        it.
    </div>

    <div class="section_subtitle">Default WorkerDefinition types</div>
    <div class="section_paragraph">
        Framework contains number of bundled
        <div class="code_inline">WorkerDefinition</div><!--remove_space-->s and default
        core
        <div class="code_inline">Scheduler</div>
        already have assigned workers for that.
        <ul>
            <li>
                <b>DEFAULT</b>: default worker for execution is synchronous. For Android platform main thread is
                used.
            </li>
            <li>
                <b>SYNCHRONOUS</b>: single worker which executes all action synchronously.
            </li>
            <li>
                <b>UI</b>: default worker for
                <div class="code_inline">ViewModelContext</div><!--remove_space-->. For Android platform main thread is
                used.
            </li>
            <li>
                <b>UI_ASYNC</b>: same as <b>UI</b>, but executes action asynchronously.
            </li>
            <li>
                <b>BACKGROUND_SINGLE_SHARED</b>: single thread background
                <div class="code_inline">Worker</div>
                which always returns same instance of
                <div class="code_inline">Worker</div>
                across whole app.
            </li>
            <li>
                <b>BACKGROUND_SINGLE_INDIVIDUAL</b>: single thread background
                <div class="code_inline">Worker</div>
                which always returns new instance of
                <div class="code_inline">Worker</div>
                for each request.
            </li>
            <li>
                <b>BACKGROUND_PARALLEL_SHARED</b>: thread pool background
                <div class="code_inline">Worker</div>
                which always returns same instance of
                <div class="code_inline">Worker</div>
                across whole app.
            </li>
            <li>
                <b>BACKGROUND_PARALLEL_INDIVIDUAL</b>: thread pool background
                <div class="code_inline">Worker</div>
                which always returns new instance of
                <div class="code_inline">Worker</div>
                for each request.
            </li>
            <li>
                <b>BACKGROUND_SERIAL</b>: background serial
                <div class="code_inline">Worker</div>
                with size of queue equal to 1 which always returns new instance of
                <div class="code_inline">Worker</div>
                for each request.
            </li>
        </ul>
    </div>

</div>
</body>
</html>